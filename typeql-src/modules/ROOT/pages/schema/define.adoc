= Define clause
:Summary: Define schema types and functions with TypeQL.
:keywords: typeql, schema, model, define, clause, modify, extend, type, function, annotations
:pageTitle: Define clause

A Define clause extends the schema of a database with new schema statements.

For a practical guide on how to send a Define query to TypeDB,
see the xref:{page-component-version}@manual::defining/define.adoc[] page of the TypeDB Manual.

// For more information on the limitations of schema manipulations, see the
// xref:{page-component-version}@home::acid.adoc#_schema_integrity[Schema integrity enforcement].

[#_syntax]
== Syntax

// tag::syntax[]
A Define clause consists of a single `define` clause and always starts with the `define` keyword.

Define queries are written in TypeQL with the following syntax:

[,typeql]
----
define <schema_definitions>
----

where `<schema_definitions>` are valid schema-specific TypeQL statements:
xref:statements/sub.adoc[],
xref:statements/owns.adoc[],
xref:statements/value.adoc[],
xref:statements/regex.adoc[],
xref:statements/relates.adoc[],
xref:statements/plays.adoc[],
and annotations: xref:annotations/key.adoc[] and xref:annotations/unique.adoc[].
Schema statements in a `define` clause can't use any variables or values.
// end::syntax[]

== Behavior

// tag::behavior[]
A Define clause adds schema statements to an existing schema.
These statements can add new types and functions,
or they can add new properties to existing types and replace existing functions.
Define queries can't change schema statements already existing in a schema, except for
xref:statements/overview.adoc#_annotation_statements[annotations].

=== Clause execution

Define queries are _idempotent_, meaning they can be applied multiple times
without changing the result of the initial application. 

A Define clause must produce a _valid_ schema in a database,
otherwise it will be rejected.

=== Clause response

A successful Define clause returns a promise of an empty response.
// end::behavior[]


== Define types

To define a new type, subtype an existing type with a xref:statements/sub.adoc[sub] statement.
Use xref:statements/owns.adoc[owns] statements to assign an ability to own attribute types.

For roles on relations, use xref:statements/relates.adoc[relates] and
xref:statements/plays.adoc[plays] statements.

Simple statements about the same subject can be combined in a
xref:statements/overview.adoc#_composite_statements[composite statement].

.Defining types example
[,typeql]
----
define

credential sub attribute, value string;
email sub attribute, value string;
full-name sub attribute, value string;
review-date sub attribute, value datetime;

subject sub entity,
    abstract,
    owns credential,
    plays permission:subject;
user sub subject, abstract;
person sub user,
    owns email,
    owns full-name;

permission sub relation,
    owns review-date,
    relates subject;
----

The above example defines four attribute types, three entity types, and a single relation type.

== Learn more

[cols-2]
--
.xref:{page-component-version}@learn::5-defining-schemas/overview.adoc[]
[.clickable]
****
Learn more about defining a schema in the TypeDB Learning course.
****

.xref:{page-component-version}@manual::defining/define.adoc[]
[.clickable]
****
See how to send a Define query to TypeDB.
****
--
