= sub / sub!

The `sub`/`sub!` keywords are used in TypeQL to declare a subtype for a given parent type.

== Syntax

The syntax of a `sub` or `sub!` statement includes:

.Syntax
[,typeql]
----
<subtype> "sub" <parent-type> ;
----

== Behavior

TypeQL statements with the `sub` keyword can be used in any kind of query: to declare new types in a schema query
or to match types in a data query.

The `sub!` keyword (with an exclamation mark) adds a constraint to a type to be a direct subtype of a given type.
The `sub` keyword (without an exclamation mark) does the same,
but it can be either a direct or indirect (nested) subtype (via type inference).
In schema queries, `sub` and `sub!` behavior is equal, since we can declare only direct subtypes in a schema statement.

== Usage in a schema definition

include::partial$iam-database-links.adoc[]

Since in Define and Undefine queries you can't use variables,
both subject and object can only be type labels in a schema statement.
So a statement with the `sub` keyword is used to define (declare) one type (preceding subject) as a subtype
of another type (succeeding object).

For example, to define a new type `pdf` as a subtype of an existing `file` type, use:

.Define query example
[,typeql]
----
define
pdf sub file;
----

== Usage in a match pattern

include::partial$iam-database-links.adoc[]

In a data query pattern a `sub` statement can be used only in a `match` clause or condition of a rule.
Both subject and object of a `sub` statement can be concept variables, or one of them can be a type label.
The `sub` keyword adds a constraint on a subject being an exact type, a direct subtype,
or indirect subtype (via type inference) of the type used as an object.

For example, to match all subtypes of a `subject` entity type, use:

.Fetching all subtypes example
[,typeql]
----
match
$subtype sub subject;
fetch
$subtype;
----

.See example output
[%collapsible]
====
.Output example
[,json]
----
{ "type": { "label": "user", "root": "entity" } }
{ "type": { "label": "business-unit", "root": "entity" } }
{ "type": { "label": "user-role", "root": "entity" } }
{ "type": { "label": "user-account", "root": "entity" } }
{ "type": { "label": "person", "root": "entity" } }
{ "type": { "label": "user-group", "root": "entity" } }
{ "type": { "label": "subject", "root": "entity" } }
----
====

.Fetching direct subtypes example
[,typeql]
----
match
$type sub! subject;
fetch $type;
----

.See example output
[%collapsible]
====
.Output example
[,json]
----
{ "type": { "label": "user", "root": "entity" } }
{ "type": { "label": "user-group", "root": "entity" } }
----
====

== Learn more

[cols-2]
--
.xref:statements/type.adoc[]
[.clickable]
****
Learn more about `type` statement in TypeQL.
****

.xref:concepts/types.adoc[]
[.clickable]
****
Learn about types in TypeQL.
****
--
